import arcpy
import sys
import os
import re
arcpy.CheckOutExtension("Spatial")

from arcpy.sa import *

def elevIndex(OutLoc, rcName, coordsysRaster, InputELEVDATAws, OutFC, version = None):
	"""
	Make a raster catalog and polygons indexed to seamless digital elevation model tiles in a directory tree. 
	
	Parameters
	----------
	OutLoc : str
		Path to output location for the raster catalog.
	rcName : str
		Namoe of the output raster catalog.
	coordsysRaster : str
		Path to raster from which to base the raster catalog's coordinate system.
	InputELEVDATAws : str
		Path to workspace containing the elevation data to be included in the raster catalog.
	OutFC : str
		Path to the output feature class.
	version : str, optional
		StreamStats DataPrepTools version number.
	
	Returns
	-------
	None

	Outputs
	-------
	OutFC : feature class
		Output feature class of polygons with an attribute describing the full path to the elevation data tiles.
	
	Description
	----------- 
	Makes a geodatabase raster catalog plus a polygon feature class containing the footprints of the 
	rasters in the raster catalog. All rasters to be loaded to the raster catalog should be on a common 
	projection and coordinate system. All rasters under the input workspace are loaded, so be sure only
	rasters of a particular type are included in the directory tree under that workspace. The primary 
	purpose of this tool is to create an index to National Elevation Dataset (NED) data, which meets the 
	above constraints. Use for other purposes has not been tested.
	
	Attribution
	-----------
	Created on: Fri Nov 13 2009 04:25:02 PM
	  (generated by ArcGIS/ModelBuilder)
	Alan Rea, ahrea@usgs.gov, 20091113, original coding
	   updated  20091231, cleanup and commenting
	   updated  20100311, removed hard-coded toolbox reference
	Theodore Barnhart, tbarnhart@usgs.gov, 20190220, moved to code.usgs.gov for version control.
	  Updated for arcpy.
	"""
	if version:
		arcpy.AddMessage('StreamStats Data Preparation Tools version: %s'%(version))

	arcpy.env.overwriteOutput=True

	Output_Raster_Catalog = os.path.join(OutLoc,rcName) 
	Raster_Management_Type = "UNMANAGED"
	coordsysPolys = coordsysRaster     # Coordinate system for polygon footprints. Use same NED grid to specify. (type Spatial Reference)

	if arcpy.Exists(OutLoc): 
		DSType = arcpy.Describe(arcpy.Describe(OutLoc).CatalogPath).WorkspaceType
		arcpy.AddMessage("Dataset type = " + DSType)
		if DSType == "FileSystem":
			arcpy.AddError("Output " + OutLoc + " is not a Geodatabase. Output location must be a Geodatabase.")
			sys.exit(0)
	else:
	  	arcpy.AddError("Output " + OutLoc + " does not exist")
	  	sys.exit(0)
	
	# Now that we're sure the geodb exists, make it the active workspace
	arcpy.Workspace = OutLoc
	arcpy.ScratchWorkspace = OutLoc
	arcpy.AddMessage("Working geodatabase is " + OutLoc)

	OutFCpath = os.path.join(OutLoc,OutFC)
	if arcpy.Exists(OutFCpath): 
		arcpy.AddError("Output feature class" + OutFCpath + "Already exists")
		sys.exit(0) # end script

	if arcpy.Exists(Output_Raster_Catalog): 
		arcpy.AddError("Output raster catalog" + Output_Raster_Catalog + "Already exists")
		sys.exit(0) # end script

	# Process: Create Raster Catalog...
	arcpy.AddMessage("Creating output raster catalog " + Output_Raster_Catalog)
	arcpy.CreateRasterCatalog_management(OutLoc, rcName, coordsysRaster, coordsysPolys, "", "0", "0", "0", Raster_Management_Type, "")
	
	# Process: Workspace To Raster Catalog...
	arcpy.AddMessage("Loading all rasters under workspace " + InputELEVDATAws + " into raster catalog...")
	arcpy.WorkspaceToRasterCatalog_management(InputELEVDATAws, Output_Raster_Catalog, "INCLUDE_SUBDIRECTORIES", "NONE") 
	
	tabName = "tmp" # maybe strip off the .dbf since the table should be inside a geodatabase.
	tmpTablePath = os.path.join(OutLoc,tabName) # generate path to temp table

	if arcpy.Exists(tmpTablePath): # if the temp table exists, delete it.
		arcpy.AddMessage("Temp table exits, deleting...")
		arcpy.Delete_management(tmpTablePath)

	#arcpy.CreateTable_management(OutLoc,tabName) # create empty table
	# Process: Export Raster Catalog paths, then join paths to raster catalog
	arcpy.AddMessage("Getting full pathnames into raster catalog")
	#out_table = ScratchName("tmp","tbl","table") # create blank table
	arcpy.ExportRasterCatalogPaths_management(Output_Raster_Catalog, "ALL", tmpTablePath)
	arcpy.JoinField_management(Output_Raster_Catalog, "OBJECTID", tmpTablePath, "SourceOID", "Path")
	
	# Process: Use Copy Features to make a polygon feature class out of the raster catalog footprints 
	arcpy.AddMessage("Making polygon index of raster catalog...")
	arcpy.CopyFeatures_management(Output_Raster_Catalog, OutFCpath)
	
	# remove temporary table 
	arcpy.AddMessage("Removing temporary table ... ")
	arcpy.Delete_management(tmpTablePath)
	 

	# handle errors and report using GPMsg function
	#except xmsg:
	#  arcpy.AddError(str(xmsg))
	#except arcgisscripting.ExecuteError:
	#  line, file, err = TraceInfo()
	#  arcpy.AddError("Geoprocessing error on %s of %s:" % (line,file))
	#  for imsg in range(0, arcpy.MessageCount):
	#    if arcpy.GetSeverity(imsg) == 2:     
	#      arcpy.AddError(imsg) # AddReturnMessage
	#except:  
	#  line, file, err = TraceInfo()
	#  arcpy.AddError("Python error on %s of %s" % (line,file))
	#  arcpy.AddError(err)
	#finally:
	  # Clean up here (delete cursors, temp files)
	#  arcpy.Delete_management(out_table)
	#  pass # you need *something* here 

def extractPoly(Input_Workspace, nedindx, clpfeat, OutGrd, version = None):
	"""
	Extracts watershed DEM from a raster catalogue of tiles based on a watershed feature.

	Parameters
	----------
	Input_Workspace : str
		Path to the workspace to work in.
	nedindx : str
		Path to the elevation data raster catalog.
	clpfeat : str
		Path to the clipping feature.
	OutGrd : str
		Name of the output grid to be generated in Input_Workspace.
	version : str, optional
		StreamStats DataPrepTools version number.

	Returns
	-------
	None

	Outputs
	-------
	OutGrd : raster
		Output extracted raster to Input_Workspace.

	Description
	-----------
	This tool extracts a polygon area from NED tiles, and merges to a single grid. This tool requires as input a polygon feature class created from a raster catalog and containing the full pathnames to each raster in the raster catalog (seamless, tiled rasters). This feature class can be created using the Make NED Index tool, also bundled with this toolbox. The polygon attribute table must contain a field named "Path", containing full pathnames to all the elevation tile grids. 
	
	Attribution
	-----------
	Alan Rea, ahrea@usgs.gov, 2009-12-31, original coding
	Theodore Barnhart, tbarnhart@usgs.gov, 2019-06-06, recode to arcpy
	"""
	if version:
		arcpy.AddMessage('StreamStats Data Preparation Tools version: %s'%(version))


	# set working folder
	arcpy.env.workspace = Input_Workspace
	arcpy.env.scratchWorkspace = arcpy.env.workspace

	# select index tiles overlapping selected poly(s)
	intersectout = os.path.join(arcpy.env.workspace,"clipintersect.shp")
	if arcpy.Exists(intersectout):
		arcpy.Delete_management(intersectout)
	
	arcpy.Clip_analysis(nedindx, clpfeat, intersectout) # clip the dataset

	MosaicList = []
	# Create search cursor 
	with arcpy.da.SearchCursor(intersectout,"Path") as cursor:
		ct = 0
		for row in cursor: # interate through each entry
			pth = row[0] # extract path

			if ct == 0:
				arcpy.AddMessage("Setting raster snap and coordinate system to match first input grid " + pth )
				try:
					assert arcpy.Exists(pth) == True
					arcpy.env.snapRaster = pth
					arcpy.env.outputCoordinateSystem = pth
				except:
					arcpy.AddError("First input grid does not exist: " + pth)
					arcpy.AddMessage("Stopping... ")
					sys.exit(0)

			arcpy.Extent = pth # set extent
			MosaicList.append(arcpy.sa.ExtractByMask(pth, clpfeat)) # extract the chunk of the DEM needed.
			ct += 1

	arcpy.Extent = clpfeat # reset extent to the whole layer
	
	arcpy.AddMessage("Merging grids to create " + OutGrd)
	arcpy.MosaicToNewRaster_management(MosaicList,arcpy.env.workspace,OutGrd,None,"32_BIT_SIGNED",None,1) # merge the grids together.

	if arcpy.Exists(intersectout):
		arcpy.Delete_management(intersectout)

def checkNoData(InGrid, tmpLoc, OutPolys_shp, version = None):
	"""
	Generates a feature class of no data values.

	Parameters
	----------
	InGrid : Raster
		Input DEM grid to search for no data values
	tmpLoc : str
		Path to workspace
	OutPoly_shp : str
		Name for output feature class
	version : str, optional
		StreamStats DataPrepTools version

	Returns
	-------
	featCount : int
		Count of no data features generated.

	Outputs
	-------
	OutPoly_shp : feature class 
		No data feature class output to tmpLoc.
	
	Converted from model builder to arcpy, Theodore Barnhart, tbarnhart@usgs.gov, 20190222
	"""
	arcpy.env.overwriteOutput = True
	if version:
		arcpy.AddMessage('StreamStats Data Preparation Tools version: %s'%(version))


	arcpy.env.extent = InGrid
	arcpy.env.cellSize = InGrid

	InGrid = Raster(InGrid)

	tmpGrid = Con(IsNull(InGrid), 1)

	# Process: Raster to Polygon
	arcpy.RasterToPolygon_conversion(tmpGrid, os.path.join(tmpLoc,OutPolys_shp), "NO_SIMPLIFY", "Value", "SINGLE_OUTER_PART", "")
	featCount = int(arcpy.GetCount_management(os.path.join(tmpLoc,OutPolys_shp)).getOutput(0))
	arcpy.AddMessage("%s no data regions found"%featCount)

	return featCount

def fillNoData(workspace, InGrid, OutGrid, version = None):
	"""
	Replaces NODATA values in a grid with mean values within 3x3 window.
	
	Parameters
	----------
	workspace : str
		Path to the workspace to work in.
	InGrid : str
		Name of the input grid to be filled.
	OutGrid : str
		Name of the output grid.
	Version : str, optional
		Code version

	Returns
	-------
	None

	Outputs
	-------
	OutGrid : raster
		Filled raster grid output to workspace.
	 
	Notes
	-----
	May be run repeatedly to fill in areas wider than 2 cells. Note the output is floating point, even if the input is integer. Note this will expand the data area of the grid around the outer edges of data, in addition to filling in NODATA gaps in the interior of the grid.
	
	Converted from model builder to arcpy, Theodore Barnhart, tbarnhart@usgs.gov, 20190222
	"""
	if version:
		arcpy.AddMessage('StreamStats Data Preparation Tools version: %s'%(version))


	OutGridPth = os.path.join(workspace, OutGrid)

	if arcpy.Exists(InGrid) == False:
		arcpy.AddError("Input grid does not exist.")
		sys.exit(0)

	if arcpy.Exists(OutGridPth):
		arcpy.AddError("Output grid exists.")
		sys.exit(0)

	arcpy.env.extent = InGrid
	arcpy.env.cellSize = InGrid
	
	InGrid = Raster(InGrid)
	
	tmpRast = Con(IsNull(InGrid), FocalStatistics(InGrid), InGrid)
	
	tmpRast.save(OutGridPth)

def projScale(Input_Workspace, InGrd, OutGrd, OutCoordsys, OutCellSize, RegistrationPoint, scaleFact = 100, version = None):
	"""
	Projects a NED grid to a user-specified coordinate system, handling cell registration. Converts
	 output grid to centimeters (multiplies by 100 and rounds).

	Parameters
	----------
	Input_Workspace : str
		Path to input workspace.
	InGrd : str
		Name of the grid to be projected and scaled.
	OutGrd : str
		Name of the output grid.
	OutCoordsys : str
		Path to the dataset to base the projection off of.
	OutCellSize : int or float
		Cell size for output grid.
	RegistrationPoint : str
		Registration point for output grid so all grids snap correctly. In the format "0 0" where the zeros are the x and y of the registration point.
	version : str
		Stream Stats version number.
	
	Returns
	-------
	None

	Outputs
	-------
	OutGrd : raster
		Rescaled and projected raster file in the input workspace.

	Attribution
	-----------
	Alan Rea, ahrea@usgs.gov, 20091216, original coding
	   ahrea, 20091231 updated comments
	Theodore Barnhart, tbarnhart@usgs.gov, 20190222
		  Converted original code to arcpy
	"""
	if version:
		arcpy.AddMessage('StreamStats Data Preparation Tools version: %s'%(version))

	try: 
		# set working folder
		arcpy.env.workspace = Input_Workspace
		arcpy.env.scratchWorkspace = arcpy.env.workspace
		tmpDEM = "tmpDEM"

		assert arcpy.Exists(InGrd), "Raster %s does not exist"%InGrid

		if arcpy.Exists(OutGrd):
			arcpy.Delete_management(OutGrd)

		if arcpy.Exists(tmpDEM):
			arcpy.Delete_management(tmpDEM)

		# clear the processing extent
		arcpy.Extent = ""
		arcpy.OutputCoordinateSystem = ""
		arcpy.SnapRaster = ""
		arcpy.AddMessage("Projecting " + InGrd + " to create " + tmpDEM)
		arcpy.ProjectRaster_management(InGrd, tmpDEM, OutCoordsys, "BILINEAR", OutCellSize, None, RegistrationPoint)

		arcpy.Extent = tmpDEM
		arcpy.OutputCoordinateSystem = OutCoordsys
		arcpy.SnapRaster = tmpDEM
		arcpy.CellSize = tmpDEM

		tmpDEMRAST = Raster(tmpDEM) # load projected raster
		
		arcpy.AddMessage("Scaling original values by %s and coverting to integers to produce %s"%(scaleFact, OutGrd))

		tmp = Int((tmpDEMRAST * scaleFact) +0.5) # convert from m to cm integers if input dem is in m and scaleFact is 100.
		# there should probably be some code here to compute the correct Zunits based on the vertical unit and the scale factor and then a check later to make sure Arc has handled it properly. 

		tmp.save(OutGrd) # save output grid

		sameUnits = compareSpatialRefUnits(OutGrd)

		sr = arcpy.Describe(OutGrd).spatialReference

		if sr.linearUnitName.upper() not in ["FEET","METER"]:
			arcpy.AddMessage("Output grid horizontal units not defined, check horizontal and vertical units.")

		# compute what the zunits should be if horizontal and vertical units are the same. Numerical zUnits should be the number of units needed to equal one meter. https://community.esri.com/thread/31951
		if sr.linearUnitCode == 9002: # EPSG for international foot
			zunits = (1./0.3048) * scaleFact
		elif sr.linearUnitCode == 9001: # EPSG for metre
			origSR = arcpy.Describe(InGrd).spatialReference
			zunits = float(origSR.ZFalseOriginAndUnits.split()[-1]) * scaleFact # for meters
		elif sr.linearUnitCode == 9003: # EPSG for US Survey Foot
			zunits = (1./0.3048006096012192) * scaleFact
		else:
			arcpy.AddMessage("Output grid horizontal units not defined, check horizontal and vertical units.")
			zunits = scaleFact

		if float(sr.ZFalseOriginAndUnits.split()[-1]) != zunits:
			arcpy.AddMessage("Zunits scale factor not set correctly, updating")
			FalseOrigin = sr.ZFalseOriginAndUnits.split()[0]
			sr.setZFalseOriginAndUnits(float(FalseOrigin), zunits)
			arcpy.DefineProjection_management(OutGrd,sr) # actually update the projection here.

		arcpy.AddMessage("Removing temporary grid %s... "%(tmpDEM))
		arcpy.Delete_management(tmpDEM)

	except:
		raise

def compareSpatialRefUnits(grd):
	'''Compare horizontal and vertical units from a raster dataset. Returns True if units are the same, returns False if they are different.

	Parameters
	----------
	grd : str
		Path to raster dataset.

	Returns
	-------
	sameUnits : bool
		True if units are the same, False if not.
	'''

	assert arcpy.Exists(grd), "%s does not exist."%grd

	sr = arcpy.Describe(grd).spatialReference

	zUnitCode = sr.ZFalseOriginAndUnits.split()[-1] # get Zunit scale factor
	xyUnits = sr.linearUnitName

	if zUnitCode == "NO":
		sameUnits = False
		arcpy.AddMessage("Zunits in %s not set and are assumed to be %s"%(xyUnits))
	else:
		sameUnits = True

	return sameUnits