import arcpy

class Toolbox(object):
    def __init__(self):
        """Toolbox for preprocessing data for creating or refreshing a StreamStats project."""
        self.label = "ELEVDATAtools"
        self.alias = "ELEVDATA processing tools"

        # List of tool classes associated with this toolbox
        self.tools = [makeELEVDATAIndex,ExtractPoly]

class makeELEVDATAIndex(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "2.A Make ELEVDATA Index"
        self.description = "Function to make ELEVDATA into a raster catalog for clipping to the basin polygons."
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        param0 = arcpy.Parameter(
            displayName = "Output Geodatabase",
            name = "OutLoc",
            datatype = "DEWorkspace",
            parameterType = "Required",
            direction = "Input")

        param1 = arcpy.Parameter(
            displayName = "Output Raster Catalog Name",
            name = "rcName",
            datatype = "GPString",
            parameterType = "Required",
            direction = "Input") 

        param1.value = "IndexRC"

        param2 = arcpy.Parameter(
            displayName = "Coordinate System",
            name = "coordsysRaster",
            datatype = "GPCoordinateSystem",
            parameterType = "Required",
            direction = "Input")

        param3 = arcpy.Parameter(
            displayName = "Input ELEV Workspace",
            name = "inputELEVws",
            datatype = "DEWorkspace",
            parameterType = "Required",
            direction = "Input")

        param4 = arcpy.Parameter(
            displayName = "Output Polygon Feature Class",
            name = "OutFC",
            datatype = "GPString",
            parameterType = "Required",
            direction = "Input")

        params = [param0,param1,param2,param3,param4]
        return params

    def execute(self, parameters, messages):
        """The source code of the tool."""

        # Make a raster catalog and polygon index to NED tiles in a directory tree. 
        # 
        # Usage: MakeNEDIndex_NHDPlusBuildRefreshTools <Output_Geodatabase> <Output_Raster_Catalog_Name> 
        #                                              <Coordinate_System> <Input_NED_Workspace> <Output_Polygon_Feature_Class>
        #        
        #
        # Description: 
        #
        # Makes a geodatabase raster catalog plus a polygon feature class containing the footprints of the 
        # rasters in the raster catalog. All rasters to be loaded to the raster catalog should be on a common 
        # projection and coordinate system. All rasters under the input workspace are loaded, so be sure only
        # rasters of a particular type are included in the directory tree under that workspace. The primary 
        # purpose of this tool is to create an index to National Elevation Dataset (NED) data, which meets the 
        # above constraints. Use for other purposes has not been tested.
        #
        # Created on: Fri Nov 13 2009 04:25:02 PM
        #   (generated by ArcGIS/ModelBuilder)
        # Alan Rea, ahrea@usgs.gov, 20091113, original coding
        #    updated  20091231, cleanup and commenting
        #    updated  20100311, removed hard-coded toolbox reference
        # Theodore Barnhart, tbarnhart@usgs.gov, 20190220, moved to code.usgs.gov for version control.
        #   Updated for arcpy.

        OutLoc = parameters[0].valueAsText
        rcName = parameters[1].valueAsText
        coordsysRaster = parameters[2].valueAsText
        InputELEVDATAws = parameters[3].valueAsText
        OutFC = parameters[4].valueAsText

        Output_Raster_Catalog = OutLoc + "\\" + rcName
        Raster_Management_Type = "Unmanaged"
        coordsysPolys = coordsysRaster     # Coordinate system for polygon footprints. Use same NED grid to specify. (type Spatial Reference)

        if arcpy.Exists(OutLoc): 
          DSType = arcpy.Describe(arcpy.Describe(OutLoc).CatalogPath).WorkspaceType
          arcpy.AddMessage("Dataset type =" + DSType)
          if DSType == "FileSystem":
            raise MsgError, "Output " + OutLoc + " is not a Geodatabase. Output location must be a Geodatabase."
        else:
          raise MsgError, "Output " + OutLoc + "does not exist"
        
        # Now that we're sure the geodb exists, make it the active workspace
        arcpy.Workspace = OutLoc
        arcpy.ScratchWorkspace = OutLoc
        arcpy.AddMessage("Working geodatabase is " + OutLoc)

        if arcpy.Exists(OutFC): 
          raise MsgError, "Output feature class" + OutFC + "Already exists"

        if arcpy.Exists(Output_Raster_Catalog): 
          raise MsgError, "Output raster catalog" + Output_Raster_Catalog + "Already exists"

        # Process: Create Raster Catalog...
        arcpy.AddMessage("Creating output raster catalog " + Output_Raster_Catalog)
        arcpy.CreateRasterCatalog_management(OutLoc, rcName, coordsysRaster, coordsysPolys, "", "0", "0", "0", Raster_Management_Type, "")
        
        # Process: Workspace To Raster Catalog...
        arcpy.AddMessage("Loading all rasters under workspace " + InputNEDWs + " into raster catalog...")
        arcpy.WorkspaceToRasterCatalog_management(InputNEDWs, Output_Raster_Catalog, "INCLUDE_SUBDIRECTORIES", "NONE")
        
        # Process: Export Raster Catalog paths, then join paths to raster catalog
        arcpy.AddMessage("Getting full pathnames into raster catalog")
        out_table = ScratchName("tmp","tbl","table")
        arcpy.exportrastercatalogpaths_management (Output_Raster_Catalog, "ALL", out_table)
        arcpy.joinfield (rcName, "OBJECTID", out_table, "SourceOID", "Path")
        
        # Process: Use Copy Features to make a polygon feature class out of the raster catalog footprints 
        arcpy.AddMessage("Making polygon index of raster catalog...")
        arcpy.CopyFeatures(rcName, OutFC)
        
        # remove temporary table 
        arcpy.AddMessage("Removing temporary table ... ")
        arcpy.Delete_management(out_table)
       

        # handle errors and report using GPMsg function
        #except xmsg:
        #  arcpy.AddError(str(xmsg))
        #except arcgisscripting.ExecuteError:
        #  line, file, err = TraceInfo()
        #  arcpy.AddError("Geoprocessing error on %s of %s:" % (line,file))
        #  for imsg in range(0, arcpy.MessageCount):
        #    if arcpy.GetSeverity(imsg) == 2:     
        #      arcpy.AddError(imsg) # AddReturnMessage
        #except:  
        #  line, file, err = TraceInfo()
        #  arcpy.AddError("Python error on %s of %s" % (line,file))
        #  arcpy.AddError(err)
        #finally:
          # Clean up here (delete cursors, temp files)
        #  arcpy.Delete_management(out_table)
        #  pass # you need *something* here 

        return

class ExtractPoly(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "2.B Extract Polygons"
        self.description = "Extract polygon area from ELEVDATA."
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        param0 = arcpy.Parameter(
            displayName = "Output Workspace",
            name = "Input_Workspace",
            datatype = "DEWorkspace",
            parameterType = "Required",
            direction = "Input")

        param1 = arcpy.Parameter(
            displayName = "ELEVDATA Index Polygons",
            name = "nedindx",
            datatype = "GPFeatureLayer",
            parameterType = "Required",
            direction = "Input")

        param2 = arcpy.Parameter(
            displayName = "Clip Polygon",
            name = "clpfeat",
            datatype = "GPFeatureLayer",
            parameterType = "Required",
            direction = "Input")

        param3 = arcpy.Parameter(
            displayName = "Output Grid",
            name = "OutGrd",
            datatype = "GPString",
            parameterType = "Required",
            direction = "Output")

        param3.value = "dem_dd"

        params = [param0,param1,param2,param3]
        return params

    def execute(self, parameters, messages):
        """The source code of the tool."""

        # This tool extracts a polygon area from NED tiles, and merges to a single grid.
        # This tool requires as input a polygon feature class created from a raster catalog and containing the 
        # full pathnames to each raster in the raster catalog (specifically NED, but probably other seamless tiled 
        # rasters would work). This feature class can be created using the Make NED Index tool, also 
        # bundled with this toolbox. The polygon attribute table must contain a field named "Path", containing
        # full pathnames to all the NED tile grids. 
        #
        # Extract an area from NED tiles
        # 
        # Usage: ExtractPolygonAreaFromNED_NHDPlusBuildRefreshTools <Output_Workspace> <NED_Index_Polygons> 
        #                                                              <Clip_Polygon> <Output_Grid>
        #
        # Alan Rea, ahrea@usgs.gov, 2009-12-31, original coding
        #

        arcpy.CheckOutExtension("Spatial") # checkout the spatial analyst extension
        Input_Workspace = parameters[0].valueAsText #workspace
        nedindx = parameters[1].valueAsText # NED Index (polygon) Layer
        clpfeat = parameters[2].valueAsText # clip polygon feature layer, I think this should be a collection of features so all the clipping happens in a loop....
        OutGrd = parameters[3].valueAsText # name of output grid

        # set working folder
        arcpy.env.Workspace = Input_Workspace
        arcpy.env.ScratchWorkspace = arcpy.Workspace

        # select index tiles overlapping selected poly(s)
        intersectout = arcpy.env.Workspace + "\\clipintersect.shp"
        if arcpy.Exists(intersectout):
          arcpy.Delete_management(intersectout)
        
        arcpy.Clip_analysis(nedindx, clpfeat, intersectout) # clip the dataset

        # Create search cursor 
        rows = arcpy.SearchCursor(intersectout) 
        row = rows.Next()
        rownum = 1

        # Make sure the "Path" field exists in the index polys--Not done yet, should do error trapping 
        #if arcpy.Exists(row):
        #desc = arcpy.Describe(row)
        #if "Path" in desc.Fields.Name 

        pth = str(row.GetValue("Path"))
        arcpy.AddMessage("Setting raster snap and coordinate system to match first input grid " + pth )
        try:
          assert arcpy.Exists(pth) == True
          arcpy.env.SnapRaster = pth
          arcpy.env.OutputCoordinateSystem = pth
        except:
          arcpy.AddError("First input grid does not exist: " + pth)
          arcpy.AddMessage("Stopping... ")
        
        #arcpy.Extent = clpfeat

        #strMosaicList = ""
        MosaicList = []
        while row: # iterate through rows (of the intersected data) and extract the relevent portion of the DEM.

          pth = str(row.GetValue("Path"))
          #OutTmpg = "tmpg" + str(rownum)
          #arcpy.AddMessage("Extracting " + pth + " to " + OutTmpg)
          arcpy.Extent = pth # set extent
          MosaicList.append(arcpy.ExtractByMask(pth, clpfeat)) # extract the chunk of the DEM needed.

          #strMosaicList = strMosaicList + OutTmpg + ","
          #rownum = rownum + 1
          row = rows.Next() # advance row cursor

        #strMosaicList = strMosaicList[:-1]
        arcpy.Extent = clpfeat # reset extent to the whole layer
        
        arcpy.AddMessage("Merging grids to create " + OutGrd)
        arcpy.Merge_management(MosaicList,OutGrd) # merge the grids together.
        
        #InExpression = "merge (" + strMosaicList + ")"
        #arcpy.SingleOutputMapAlgebra_sa(InExpression, OutGrd)

        ## No Longer Needed I think
        #arcpy.AddMessage("Removing temporary grids ... ")
        #n = 1
        #while n < rownum:
        #  tmpnm = "tmpg" + str(n)
        #  arcpy.Delete_management(tmpnm)
        #  n = n + 1

        del rows
         
        # handle errors and report using GPMsg function
        #except MsgError, xmsg:
        #  GPMsg("Error",str(xmsg))
        #except arcgisscripting.ExecuteError:
        #  line, file, err = TraceInfo()
        #  GPMsg("Error","Geoprocessing error on %s of %s:" % (line,file))
        #  for imsg in range(0, arcpy.MessageCount):
        #    if arcpy.GetSeverity(imsg) == 2:     
        #      GPMsg("Return",imsg) # AddReturnMessage
        #except:  
        #  line, file, err = TraceInfo()
        #  GPMsg("Error","Python error on %s of %s" % (line,file))
        #  GPMsg("Error",err)
        #finally:
        #  # Clean up here (delete cursors, temp files)
        #  arcpy.Delete_management(intersectout) # remove the intersect data
        #  pass # you need *something* here 
        return

class Setup(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "Setup"
        self.description = "Generate the file structure for Stream Stats Data Preprocessing."
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        params = None
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        return